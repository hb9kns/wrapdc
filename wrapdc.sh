#!/bin/sh
# wrapper for dc
# global status file
statf=$HOME/.wdcrc
# if nonexistent, populate with precision 2, clear stack and memories
if test ! -r $statf
then echo '2k 0 0 0 0 0 0s00s10s20s30s40s50s60s70s80s9' >$statf
fi

if test "$1" = "-v"
then verbose='echo' ; shift
else verbose=':'
fi

# macros defined as sed patterns
# (kill all '!' not part of comparison commands)
mcrs='
s,%t,SAdLA100*SASBLALB/,g;# percent part: X:=100*(X/Y), Y kept
s,%,SAdLA*100/,g;# percentage: X:=X*Y/100, Y kept
s,rem,\%,g;# remainder: X:=Y%X (instead of normal '%' command)
s,sto\(.\),s\1l\1,g;# sto.: store with copying (i.e keep value on stack)
s,fact,[SAlA*LA1-d0<B]SBSA1LAlBx0*sBLB+,g;# factorial: X:=X!
s,neg,_1*,g;# negate: X:=-X
s,r,SRSTLRLT,g;# revert: X:=Y, Y:=X ('r' is a GNU only extension)
 s,![ 	]*[^<=>],#,
'
# get stored stack from statf, process input, and finish with
# storing current precision (like "2k"), memories, and top 5 of stack,
# and print stack top ("X register")
cycl(){
# get status, ignore error lines from unknown commands
 stat=`grep -v unimplemented $statf`
# process direct commands
 case $1 in
 help*) cat <<EOH >&2
wrapper for dc // 2016 Y.Bonetti // see https://gitlab.com/yargo/wrapdc
 top 5 stack positions, registers 0-9 and precision are saved
  in '$statf'
direct commands:
 list (defined macros)
 verb (verbose display: status and arguments) | noverb (normal display)
stack top value is displayed after each processed line:
EOH
 ;;
 verb*) verbose='echo' ;;
 noverb*) verbose=':' ;;
 list*) echo "$mcrs"|grep '^s,'|sed -e 's/s,/: /;s/,.*#/ #/' >&2 ;;
# if no command, get args, convert macros
 *) args=`echo "$@"|sed -e "$mcrs"` ;;
 esac
$verbose :status: "$stat"
$verbose :arguments: "$args" >&2
$verbose >&2
 cat <<ENDOFDCINPUT | dc 2>/dev/null | sed -e 's/^-/_/' >$statf
$stat
$args
# save stack in registers A-E
SASBSCSDSE
# print precision and 'k' and 'c' to clear stack when loading
Kn[kc
]n
# print contents of registers 0-9 (memories) and storage command
l0n[s0
]nl1n[s1
]nl2n[s2
]nl3n[s3
]nl4n[s4
]nl5n[s5
]nl6n[s6
]nl7n[s7
]nl8n[s8
]nl9n[s9
]n
# clear stack, store 0 in reg.Z and macro in reg.Y, which compares stack
# depth with 1 (in case of empty stack generated by this '1') and if equal,
# prints 0 (from reg.Z), else former top of stack, and clears stack
c 0sZ [1z=Zpc]sY
# apply macro in reg.Y to all saved stack values
LElYx LDlYx LClYx LBlYx LAlYx
ENDOFDCINPUT
# print stack top
 tail -n 1 $statf
}

if test "$1" = ""
# process STDIN ..
then while read line
 do case $line in
  q*) exit ;;
  esac
  cycl "$line"
 done
# .. or arguments
else cycl "$@"
fi
